var app = angular.module('ASMSimulator', []);
;app.service('assembler', ['opcodes', function (opcodes) {
    return {
        go: function (input) {
            // Use https://www.debuggex.com/
            // Matches: "label: INSTRUCTION (["')OPERAND1(]"'), (["')OPERAND2(]"')
            // GROUPS:      1       2               3                    7
            var regex = /^[\t ]*(?:([.A-Za-z]\w*)[:])?(?:[\t ]*([A-Za-z]{2,4})(?:[\t ]+(\[(\w+((\+|-)\d+)?)\]|\".+?\"|\'.+?\'|[.A-Za-z0-9]\w*)(?:[\t ]*[,][\t ]*(\[(\w+((\+|-)\d+)?)\]|\".+?\"|\'.+?\'|[.A-Za-z0-9]\w*))?)?)?/;

            // Regex group indexes for operands
            var op1_group = 3;
            var op2_group = 7;

            // MATCHES: "(+|-)INTEGER"
            var regexNum = /^[-+]?[0-9]+$/;
            // MATCHES: "(.L)abel"
            var regexLabel = /^[.A-Za-z]\w*$/;
            // Contains the program code & data generated by the assembler
            var code = [];
            // Contains the mapping from instructions to assembler line
            var mapping = {};
            // Hash map of label used to replace the labels after the assembler generated the code
            var labels = {};
            // Hash of uppercase labels used to detect duplicates
            var normalizedLabels = {};

            // Split text into code lines
            var lines = input.split('\n');

            // Allowed formats: 200, 200d, 0xA4, 0o48, 101b
            var parseNumber = function (input) {
                if (input.slice(0, 2) === "0x") {
                    return parseInt(input.slice(2), 16);
                } else if (input.slice(0, 2) === "0o") {
                    return parseInt(input.slice(2), 8);
                } else if (input.slice(input.length - 1) === "b") {
                    return parseInt(input.slice(0, input.length - 1), 2);
                } else if (input.slice(input.length - 1) === "d") {
                    return parseInt(input.slice(0, input.length - 1), 10);
                } else if (regexNum.exec(input)) {
                    return parseInt(input, 10);
                } else {
                    throw "Invalid number format";
                }
            };

            // Allowed registers: A, B, C, M, SP
            var parseRegister = function (input) {
                input = input.toUpperCase();

                if (input === 'A') {
                    return 0;
                } else if (input === 'B') {
                    return 1;
                } else if (input === 'C') {
                    return 2;
                } else if (input === 'M') {
                    return 3;
                } else if (input === 'SP') {
                    return 4;
                } else {
                    return undefined;
                }
            };

            var parseOffsetAddressing = function (input) {
                input = input.toUpperCase();
                var m = 0;
                var base = 0;

                if (input[0] === 'A') {
                    base = 0;
                } else if (input[0] === 'B') {
                    base = 1;
                } else if (input[0] === 'C') {
                    base = 2;
                } else if (input[0] === 'M') {
                    base = 3;
                } else if (input.slice(0, 2) === "SP") {
                    base = 4;
                } else {
                    return undefined;
                }
                var offset_start = 1;
                if (base === 4) {
                    offset_start = 2;
                }

                if (input[offset_start] === '-') {
                    m = -1;
                } else if (input[offset_start] === '+') {
                    m = 1;
                } else {
                    return undefined;
                }

                var offset = m * parseInt(input.slice(offset_start + 1), 10);

                if (offset < -16 || offset > 15)
                    throw "offset must be a value between -16...+15";

                if (offset < 0) {
                    offset = 32 + offset; // two's complement representation in 5-bit
                }

                return offset * 8 + base; // shift offset 3 bits right and add code for register
            };

            // Allowed: Register, Label or Number; SP+/-Number is allowed for 'regaddress' type
            var parseRegOrNumber = function (input, typeReg, typeNumber) {
                var register = parseRegister(input);

                if (register !== undefined) {
                    return {type: typeReg, value: register};
                } else {
                    var label = parseLabel(input);
                    if (label !== undefined) {
                        return {type: typeNumber, value: label};
                    } else {
                        if (typeReg === "regaddress") {

                            register = parseOffsetAddressing(input);

                            if (register !== undefined) {
                                return {type: typeReg, value: register};
                            }
                        }

                        var value = parseNumber(input);

                        if (isNaN(value)) {
                            throw "Not a " + typeNumber + ": " + value;
                        }
                        else if (value < 0 || value > 255)
                            throw typeNumber + " must have a value between 0-255";

                        return {type: typeNumber, value: value};
                    }
                }
            };

            var parseLabel = function (input) {
                return regexLabel.exec(input) ? input : undefined;
            };

            var getValue = function (input) {
                switch (input.slice(0, 1)) {
                    case '[': // [number] or [register]
                        var address = input.slice(1, input.length - 1);
                        return parseRegOrNumber(address, "regaddress", "address");
                    case '"': // "String"
                        var text = input.slice(1, input.length - 1);
                        var chars = [];

                        for (var i = 0, l = text.length; i < l; i++) {
                            chars.push(text.charCodeAt(i));
                        }

                        return {type: "numbers", value: chars};
                    case "'": // 'C'
                        var character = input.slice(1, input.length - 1);
                        if (character.length > 1)
                            throw "Only one character is allowed. Use String instead";

                        return {type: "number", value: character.charCodeAt(0)};
                    default: // REGISTER, NUMBER or LABEL
                        return parseRegOrNumber(input, "register", "number");
                }
            };

            var addLabel = function (label) {
                var upperLabel = label.toUpperCase();
                if (upperLabel in normalizedLabels)
                    throw "Duplicate label: " + label;

                if (upperLabel === "A" || upperLabel === "B" || upperLabel === "C" || upperLabel === "M")
                    throw "Label contains keyword: " + upperLabel;

                labels[label] = code.length;
            };

            var checkNoExtraArg = function (instr, arg) {
                if (arg !== undefined) {
                    throw instr + ": too many arguments";
                }
            };

            for (var i = 0, l = lines.length; i < l; i++) {
                try {
                    var match = regex.exec(lines[i]);
                    if (match[1] !== undefined || match[2] !== undefined) {
                        if (match[1] !== undefined) {
                            addLabel(match[1]);
                        }

                        if (match[2] !== undefined) {
                            var instr = match[2].toUpperCase();
                            var p1, p2, opCode;

                            // Add mapping instr pos to line number
                            // Don't do it for DB as this is not a real instruction
                            if (instr !== 'DB') {
                                mapping[code.length] = i;
                            }

                            switch (instr) {
                                case 'DB':
                                    p1 = getValue(match[op1_group]);

                                    if (p1.type === "number") {
                                        code.push(p1.value);
                                    }
                                    else if (p1.type === "numbers")
                                        for (var j = 0, k = p1.value.length; j < k; j++) {
                                            code.push(p1.value[j]);
                                        }
                                    else
                                        throw "DB does not support this operand";
                                    break;
                                case 'GOTO':
                                    p1 = getValue(match[op1_group]);

                                    if (p1.type === "number") {
                                        code.push(opcodes.LIX);
                                        mapping[code.length] = i+1;
                                        code.push(p1.value);
                                        mapping[code.length] = i+2;
                                        opCode = opcodes.MMA;
                                        code.push(opCode);
                                        mapping[code.length] = i+3;
                                        opCode = opcodes.JMP;
                                        code.push(opCode);
                                    }
                                    break;
                                case 'HLT':
                                    checkNoExtraArg('HLT', match[op1_group]);
                                    opCode = opcodes.HLT;
                                    code.push(opCode);
                                    break;
                                case 'NOP':
                                    checkNoExtraArg('NOP', match[op1_group]);
                                    opCode = opcodes.NOP;
                                    code.push(opCode);
                                    break;

                                case 'ADL':
                                    checkNoExtraArg('ADL', match[op1_group]);
                                    opCode = opcodes.ADL;
                                    code.push(opCode);
                                    break;
                                case 'ADH':
                                    checkNoExtraArg('ADH', match[op1_group]);
                                    opCode = opcodes.ADH;
                                    code.push(opCode);
                                    break;
                                case 'AND':
                                    checkNoExtraArg('AND', match[op1_group]);
                                    opCode = opcodes.AND;
                                    code.push(opCode);
                                    break;
                                case 'OR':
                                    checkNoExtraArg('OR', match[op1_group]);
                                    opCode = opcodes.OR;
                                    code.push(opCode);
                                    break;
                                case 'XOR':
                                    checkNoExtraArg('XOR', match[op1_group]);
                                    opCode = opcodes.XOR;
                                    code.push(opCode);
                                    break;
                                case 'NOT':
                                    checkNoExtraArg('NOT', match[op1_group]);
                                    opCode = opcodes.NOT;
                                    code.push(opCode);
                                    break;
                                case 'CLC':
                                    checkNoExtraArg('CLC', match[op1_group]);
                                    opCode = opcodes.CLC;
                                    code.push(opCode);
                                    break;
                                case 'SEC':
                                    checkNoExtraArg('SEC', match[op1_group]);
                                    opCode = opcodes.SEC;
                                    code.push(opCode);
                                    break;
                                case 'SHL':
                                    checkNoExtraArg('SHL', match[op1_group]);
                                    opCode = opcodes.SHL;
                                    code.push(opCode);
                                    break;
                                case 'SHR':
                                    checkNoExtraArg('SHR', match[op1_group]);
                                    opCode = opcodes.SHR;
                                    code.push(opCode);
                                    break;
                                case 'JMP':
                                    checkNoExtraArg('JMP', match[op1_group]);
                                    opCode = opcodes.JMP;
                                    code.push(opCode);
                                    break;
                                case 'JNE':
                                    checkNoExtraArg('JNE', match[op1_group]);
                                    opCode = opcodes.JNE;
                                    code.push(opCode);
                                    break;
                                case 'LDA':
                                    checkNoExtraArg('LDA', match[op1_group]);
                                    opCode = opcodes.LDA;
                                    code.push(opCode);
                                    break;
                                case 'STA':
                                    checkNoExtraArg('STA', match[op1_group]);
                                    opCode = opcodes.STA;
                                    code.push(opCode);
                                    break;
                                case 'MAC':
                                    checkNoExtraArg('MAC', match[op1_group]);
                                    opCode = opcodes.MAC;
                                    code.push(opCode);
                                    break;
                                case 'MBA':
                                    checkNoExtraArg('MBA', match[op1_group]);
                                    opCode = opcodes.MBA;
                                    code.push(opCode);
                                    break;
                                case 'MAM':
                                    checkNoExtraArg('MAM', match[op1_group]);
                                    opCode = opcodes.MAM;
                                    code.push(opCode);
                                    break;
                                case 'MMA':
                                    checkNoExtraArg('MMA', match[op1_group]);
                                    opCode = opcodes.MMA;
                                    code.push(opCode);
                                    break;
                                case 'MPA':
                                    checkNoExtraArg('MAP', match[op1_group]);
                                    opCode = opcodes.MAP;
                                    code.push(opCode);
                                    break;
                                case 'MGM':
                                    checkNoExtraArg('MGM', match[op1_group]);
                                    opCode = opcodes.MGM;
                                    code.push(opCode);
                                    break;
                                case 'MLG':
                                    checkNoExtraArg('MLG', match[op1_group]);
                                    opCode = opcodes.MLG;
                                    code.push(opCode);
                                    break;
                                case 'MGL':
                                    checkNoExtraArg('MGL', match[op1_group]);
                                    opCode = opcodes.MGL;
                                    code.push(opCode);
                                    break;
                                case 'IXR':
                                    checkNoExtraArg('IXR', match[op1_group]);
                                    opCode = opcodes.IXR;
                                    code.push(opCode);
                                    break;
                                case 'IXN':
                                    checkNoExtraArg('IXN', match[op1_group]);
                                    opCode = opcodes.IXN;
                                    code.push(opCode);
                                    break;
                                case 'LIL':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg('LIL', match[op2_group]);
                                    if (p1.type === "number")
                                        switch (p1.value) {
                                            case 0:
                                                opCode = opcodes.LIL_0;
                                                break;
                                            case 1:
                                                opCode = opcodes.LIL_1;
                                                break;
                                            case 2:
                                                opCode = opcodes.LIL_2;
                                                break;
                                            case 3:
                                                opCode = opcodes.LIL_3;
                                                break;
                                            case 4:
                                                opCode = opcodes.LIL_4;
                                                break;
                                            case 5:
                                                opCode = opcodes.LIL_5;
                                                break;
                                            case 6:
                                                opCode = opcodes.LIL_6;
                                                break;
                                            case 7:
                                                opCode = opcodes.LIL_7;
                                                break;
                                            case 8:
                                                opCode = opcodes.LIL_8;
                                                break;
                                            case 9:
                                                opCode = opcodes.LIL_9;
                                                break;
                                            case 10:
                                                opCode = opcodes.LIL_A;
                                                break;
                                            case 11:
                                                opCode = opcodes.LIL_B;
                                                break;
                                            case 12:
                                                opCode = opcodes.LIL_C;
                                                break;
                                            case 13:
                                                opCode = opcodes.LIL_D;
                                                break;
                                            case 14:
                                                opCode = opcodes.LIL_E;
                                                break;
                                            case 15:
                                                opCode = opcodes.LIL_F;
                                                break;
                                            default:
                                                throw "Incorrect value for LIL";
                                        }
                                    else
                                        throw instr + " does not suppport this operand";
                                    code.push(opCode);
                                    break;
                                case 'LIH':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg('LIH', match[op2_group]);
                                    if (p1.type === "number")
                                        switch (p1.value) {
                                            case 0:
                                                opCode = opcodes.LIH_0;
                                                break;
                                            case 1:
                                                opCode = opcodes.LIH_1;
                                                break;
                                            case 2:
                                                opCode = opcodes.LIH_2;
                                                break;
                                            case 3:
                                                opCode = opcodes.LIH_3;
                                                break;
                                            case 4:
                                                opCode = opcodes.LIH_4;
                                                break;
                                            case 5:
                                                opCode = opcodes.LIH_5;
                                                break;
                                            case 6:
                                                opCode = opcodes.LIH_6;
                                                break;
                                            case 7:
                                                opCode = opcodes.LIH_7;
                                                break;
                                            case 8:
                                                opCode = opcodes.LIH_8;
                                                break;
                                            case 9:
                                                opCode = opcodes.LIH_9;
                                                break;
                                            case 10:
                                                opCode = opcodes.LIH_A;
                                                break;
                                            case 11:
                                                opCode = opcodes.LIH_B;
                                                break;
                                            case 12:
                                                opCode = opcodes.LIH_C;
                                                break;
                                            case 13:
                                                opCode = opcodes.LIH_D;
                                                break;
                                            case 14:
                                                opCode = opcodes.LIH_E;
                                                break;
                                            case 15:
                                                opCode = opcodes.LIH_F;
                                                break;
                                            default:
                                                throw "Incorrect value for LIH";
                                        }
                                    else
                                        throw instr + " does not suppport this operand";
                                    code.push(opCode);
                                    break;
                                case 'LIX':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg('LIX', match[op2_group]);
                                    opCode = opcodes.LIX;
                                    code.push(opCode);
                                    mapping[code.length] = i+1;
                                    code.push(p1.value);
                                    break;
                                default:
                                    throw "Invalid instruction: " + match[2];
                            }
                        }
                    } else {
                        // Check if line starts with a comment otherwise the line contains an error and can not be parsed
                        var line = lines[i].trim();
                        if (line !== "" && line.slice(0, 1) !== ";") {
                            throw "Syntax error";
                        }
                    }
                } catch (e) {
                    throw {error: e, line: i};
                }
            }

            // Replace label
            for (i = 0, l = code.length; i < l; i++) {
                if (!angular.isNumber(code[i])) {
                    if (code[i] in labels) {
                        if (i - 1 >= 0) {
                            if (code[i - 1] == opcodes.LIX) {
                                code[i - 1] = opcodes.LIL_0 + (labels[code[i]] & 0x0F);
                                code[i] = opcodes.LIH_0 + (labels[code[i]] >>> 4);
                            }
                            else {
                                code[i] = labels[code[i]];
                            }
                        }
                        else {
                            code[i] = labels[code[i]];
                        }
                    } else {

                        throw {error: "Undefined label: " + code[i]};
                    }
                }
            }

            return {code: code, mapping: mapping, labels: labels};
        }
    };
}]);
;app.service('cpu', ['opcodes', 'memory', function(opcodes, memory) {
    var cpu = {
        step: function() {
            var self = this;

            if (self.fault === true) {
                throw "FAULT. Reset to continue.";
            }

            try {
                var checkGPR = function(reg) {
                    if (reg < 0 || reg >= self.gpr.length) {
                        throw "Invalid register: " + reg;
                    } else {
                        return reg;
                    }
                };

                var checkGPR_SP = function(reg) {
                    if (reg < 0 || reg >= 1 + self.gpr.length) {
                        throw "Invalid register: " + reg;
                    } else {
                        return reg;
                    }
                };

                var setGPR_SP = function(reg,value)
                {
                    if(reg >= 0 && reg < self.gpr.length) {
                        self.gpr[reg] = value;
                    } else if(reg == self.gpr.length) {
                        self.sp = value;

                        // Not likely to happen, since we always get here after checkOpertion().
                        if (self.sp < self.minSP) {
                            throw "Stack overflow";
                        } else if (self.sp > self.maxSP) {
                            throw "Stack underflow";
                        }
                    } else {
                        throw "Invalid register: " + reg;
                    }
                };

                var getGPR_SP = function(reg)
                {
                    if(reg >= 0 && reg < self.gpr.length) {
                        return self.gpr[reg];
                    } else if(reg == self.gpr.length) {
                        return self.sp;
                    } else {
                        throw "Invalid register: " + reg;
                    }
                };

                var indirectRegisterAddress = function(value) {
                    var reg = value % 8;
                    
                    var base;
                    if (reg < self.gpr.length) {
                        base = self.gpr[reg];
                    } else {
                        base = self.sp;
                    }
                    
                    var offset = Math.floor(value / 8);
                    if ( offset > 15 ) {
                        offset = offset - 32;
                    }
                    
                    return base+offset;
                };

                var checkOperation = function(value) {
                    self.zero = false;
                    self.carry = false;

                    if (value >= 256) {
                        self.carry = true;
                        value = value % 256;
                    } else if (value === 0) {
                        self.zero = true;
                    } else if (value < 0) {
                        self.carry = true;
                        value = 256 - (-value) % 256;
                    }

                    return value;
                };

                var jump = function(newIP) {
                    if (newIP-1 < 0 || newIP >= memory.data.length) {
                        throw "IP outside memory";
                    } else {
                        self.pc = newIP-1;
                    }
                };

                var push = function(value) {
                    memory.store(self.sp--, value);
                    if (self.sp < self.minSP) {
                        throw "Stack overflow";
                    }
                };

                var pop = function() {
                    var value = memory.load(++self.sp);
                    if (self.sp > self.maxSP) {
                        throw "Stack underflow";
                    }

                    return value;
                };

                var division = function(divisor) {
                    if (divisor === 0) {
                        throw "Division by 0";
                    }

                    return Math.floor(self.gpr[0] / divisor);
                };

                if (self.pc < 0 || self.pc >= memory.data.length) {
                    throw "Instruction pointer is outside of memory";
                }
                
                var instr = memory.load(self.pc);
                switch(instr) {
                    case opcodes.HLT:
                        return false;
                    case opcodes.NOP:
                        self.pc++;
                        break;
                    case opcodes.ADL:
                        setGPR_SP(checkGPR_SP(2),((getGPR_SP(2) & 0xF0)+(getGPR_SP(0) & 0x0F)+(getGPR_SP(1) & 0x0F)+self.carry) & 0xFF);
                        if ((getGPR_SP(0) & 0x0F)+(getGPR_SP(1) & 0x0F)+self.carry > 15){
                            self.carry = true;
                        }
                        else{
                            self.carry = false;
                        }
                        self.pc++;
                        break;
                    case opcodes.ADH:
                        setGPR_SP(checkGPR_SP(2),(getGPR_SP(2) & 0x0F)+((getGPR_SP(0) & 0xF0)+((getGPR_SP(1) & 0xF0)+(self.carry << 4))) & 0xFF);
                        if (((getGPR_SP(0) & 0xF0) >> 4)+((getGPR_SP(1) & 0xF0) >> 4)+self.carry > 15){
                            self.carry = true;
                        }
                        else{
                            self.carry = false;
                        }
                        self.pc++;
                        break;
                    case opcodes.AND:
                        setGPR_SP(checkGPR_SP(2), getGPR_SP(0) & getGPR_SP(1));
                        self.pc++;
                        break;
                    case opcodes.OR:
                        setGPR_SP(checkGPR_SP(2), getGPR_SP(0) | getGPR_SP(1));
                        self.pc++;
                        break;
                    case opcodes.XOR:
                        setGPR_SP(checkGPR_SP(2), getGPR_SP(0) ^ getGPR_SP(1));
                        self.pc++;
                        break;
                    case opcodes.NOT:
                        setGPR_SP(checkGPR_SP(2), ((~getGPR_SP(0))>>>0) & 0xFF);
                        self.pc++;
                        break;
                    case opcodes.CLC:
                        self.carry = false;
                        self.pc++;
                        break;
                    case opcodes.SEC:
                        self.carry = true;
                        self.pc++;
                        break;
                    case opcodes.SHL:
                        setGPR_SP(checkGPR_SP(2), (getGPR_SP(0) << 1) & 0xFF);
                        self.carry = getGPR_SP(0) >>> 7 == 1 ? true : false;
                        self.pc++;
                        break;
                    case opcodes.SHR:
                        setGPR_SP(checkGPR_SP(2), getGPR_SP(0) >>> 1);
                        self.carry = getGPR_SP(0) & 0x01 == 1 ? true : false;
                        self.pc++;
                        break;
                    case opcodes.JMP:
                        jump(getGPR_SP(3));
                        self.pc++;
                        break;
                    case opcodes.JNE:
                        if (getGPR_SP(2) !== 0){
                            jump(getGPR_SP(3));
                        }
                        self.pc++;
                        break;
                    case opcodes.LDA:
                        setGPR_SP(checkGPR_SP(0), memory.load(getGPR_SP(3)));
                        self.pc++;
                        break;
                    case opcodes.STA:
                        memory.store(getGPR_SP(3), getGPR_SP(0));
                        self.pc++;
                        break;
                    case opcodes.MAC:
                        setGPR_SP(checkGPR_SP(0), getGPR_SP(2));
                        self.pc++;
                        break;
                    case opcodes.MBA:
                        setGPR_SP(checkGPR_SP(1), getGPR_SP(0));
                        self.pc++;
                        break;
                    case opcodes.MAM:
                        setGPR_SP(checkGPR_SP(0), getGPR_SP(3));
                        self.pc++;
                        break;
                    case opcodes.MMA:
                        setGPR_SP(checkGPR_SP(3), getGPR_SP(0));
                        self.pc++;
                        break;
                    case opcodes.MAP:
                        setGPR_SP(checkGPR_SP(0), self.pc);
                        self.pc++;
                        break;
                    case opcodes.MGM:
                        self.pc++;
                        break;
                    case opcodes.MLG:
                        self.pc++;
                        break;
                    case opcodes.MGL:
                        self.pc++;
                        break;
                    case opcodes.IXR:
                        self.pc++;
                        break;
                    case opcodes.IXN:
                        self.pc++;
                        break;
                    case opcodes.LIL_0:
                        setGPR_SP(checkGPR_SP(0), (getGPR_SP(0) & 0xF0)+0);
                        self.pc++;
                        break;
                    case opcodes.LIL_1:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0xF0)+1));
                        self.pc++;
                        break;
                    case opcodes.LIL_2:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0xF0)+2));
                        self.pc++;
                        break;
                    case opcodes.LIL_3:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0xF0)+3));
                        self.pc++;
                        break;
                    case opcodes.LIL_4:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0xF0)+4));
                        self.pc++;
                        break;
                    case opcodes.LIL_5:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0xF0)+5));
                        self.pc++;
                        break;
                    case opcodes.LIL_6:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0xF0)+6));
                        self.pc++;
                        break;
                    case opcodes.LIL_7:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0xF0)+7));
                        self.pc++;
                        break;
                    case opcodes.LIL_8:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0xF0)+8));
                        self.pc++;
                        break;
                    case opcodes.LIL_9:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0xF0)+9));
                        self.pc++;
                        break;
                    case opcodes.LIL_A:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0xF0)+10));
                        self.pc++;
                        break;
                    case opcodes.LIL_B:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0xF0)+11));
                        self.pc++;
                        break;
                    case opcodes.LIL_C:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0xF0)+12));
                        self.pc++;
                        break;
                    case opcodes.LIL_D:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0xF0)+13));
                        self.pc++;
                        break;
                    case opcodes.LIL_E:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0xF0)+14));
                        self.pc++;
                        break;
                    case opcodes.LIL_F:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0xF0)+15));
                        self.pc++;
                        break;
                    case opcodes.LIH_0:
                        setGPR_SP(checkGPR_SP(0), (getGPR_SP(0) & 0x0F)+(0<<4));
                        self.pc++;
                        break;
                    case opcodes.LIH_1:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0x0F)+(1<<4)));
                        self.pc++;
                        break;
                    case opcodes.LIH_2:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0x0F)+(2<<4)));
                        self.pc++;
                        break;
                    case opcodes.LIH_3:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0x0F)+(3<<4)));
                        self.pc++;
                        break;
                    case opcodes.LIH_4:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0x0F)+(4<<4)));
                        self.pc++;
                        break;
                    case opcodes.LIH_5:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0x0F)+(5<<4)));
                        self.pc++;
                        break;
                    case opcodes.LIH_6:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0x0F)+(6<<4)));
                        self.pc++;
                        break;
                    case opcodes.LIH_7:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0x0F)+(7<<4)));
                        self.pc++;
                        break;
                    case opcodes.LIH_8:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0x0F)+(8<<4)));
                        self.pc++;
                        break;
                    case opcodes.LIH_9:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0x0F)+(9<<4)));
                        self.pc++;
                        break;
                    case opcodes.LIH_A:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0x0F)+(10<<4)));
                        self.pc++;
                        break;
                    case opcodes.LIH_B:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0x0F)+(11<<4)));
                        self.pc++;
                        break;
                    case opcodes.LIH_C:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0x0F)+(12<<4)));
                        self.pc++;
                        break;
                    case opcodes.LIH_D:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0x0F)+(13<<4)));
                        self.pc++;
                        break;
                    case opcodes.LIH_E:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0x0F)+(14<<4)));
                        self.pc++;
                        break;
                    case opcodes.LIH_F:
                        setGPR_SP(checkGPR_SP(0), checkOperation((getGPR_SP(0) & 0x0F)+(15<<4)));
                        self.pc++;
                        break;
                    default:
                        throw "Invalid op code: " + instr;
                }

                return true;
            } catch(e) {
                self.fault = true;
                throw e;
            }
        },
        reset: function() {
            var self = this;
            self.maxSP = 231;
            self.minSP = 0;

            self.gpr = [0, 0, 0, 0];
            self.sp = self.maxSP;
            self.pc = 0;
            self.zero = false;
            self.carry = false;
            self.fault = false;
        }
    };

    cpu.reset();
    return cpu;
}]);
;app.service('memory', [function () {
    var memory = {
        data: Array(256),
        lastAccess: -1,
        load: function (address) {
            var self = this;

            if (address < 0 || address >= self.data.length) {
                throw "Memory access violation at " + address;
            }

            self.lastAccess = address;
            return self.data[address];
        },
        store: function (address, value) {
            var self = this;

            if (address < 0 || address >= self.data.length) {
                throw "Memory access violation at " + address;
            }

            self.lastAccess = address;
            self.data[address] = value;
        },
        reset: function () {
            var self = this;

            self.lastAccess = -1;
            for (var i = 0, l = self.data.length; i < l; i++) {
                self.data[i] = 0;
            }
        }
    };

    memory.reset();
    return memory;
}]);
;app.service('opcodes', [function() {
    var opcodes = {
        HLT: 0,
	NOP: 1,
	ADL: 5,
	ADH: 7,
	AND: 8,
	OR: 9,
	XOR: 10,
	NOT: 11,
	CLC: 12,
	SEC: 13,
	SHL: 14,
	SHR: 15,
	JMP: 16,
	JNE: 17,
	LDA: 33,
	STA: 34,
	MAC: 35,
	MBA: 36,
	MAM: 37,
	MMA: 38,
	MAP: 39,
	MGM: 40,
	MLG: 41,
	MGL: 42,
	IXR: 43,
	IXN: 44,
	LIX: 63,
	LIL_0: 64,
	LIL_1: 65,
	LIL_2: 66,
	LIL_3: 67,
	LIL_4: 68,
	LIL_5: 69,
	LIL_6: 70,
	LIL_7: 71,
	LIL_8: 72,
	LIL_9: 73,
	LIL_A: 74,
	LIL_B: 75,
	LIL_C: 76,
	LIL_D: 77,
	LIL_E: 78,
	LIL_F: 79,
	LIH_0: 80,
	LIH_1: 81,
	LIH_2: 82,
	LIH_3: 83,
	LIH_4: 84,
	LIH_5: 85,
	LIH_6: 86,
	LIH_7: 87,
	LIH_8: 88,
	LIH_9: 89,
	LIH_A: 90,
	LIH_B: 91,
	LIH_C: 92,
	LIH_D: 93,
	LIH_E: 94,
	LIH_F: 95
    };

    return opcodes;
}]);
;app.controller('Ctrl', ['$document', '$scope', '$timeout', 'cpu', 'memory', 'assembler', function ($document, $scope, $timeout, cpu, memory, assembler) {
    $scope.memory = memory;
    $scope.cpu = cpu;
    $scope.error = '';
    $scope.isRunning = false;
    $scope.displayHex = true;
    $scope.displayInstr = true;
    $scope.displayA = false;
    $scope.displayB = false;
    $scope.displayC = false;
    $scope.displayM = false;
    $scope.speeds = [{speed: 1, desc: "1 HZ"},
                     {speed: 4, desc: "4 HZ"},
                     {speed: 8, desc: "8 HZ"},
                     {speed: 16, desc: "16 HZ"}];
    $scope.speed = 4;
    $scope.outputStartIndex = 232;

    $scope.code = "GOTO start\n\nDB \"Hello World!\"\nDB 0\n\nstart:\nLIL 0x0\nLIH 0x0\nMBA\n\nLIL 0x7\nLIH 0xE\nMMA\nSTA\n\nLIL 0x6\nLIH 0xE\nMMA\nLIL 0x4\nLIH 0x0\nSTA\n\nloop:\nLIL 0x7\nLIH 0xE\nMMA\nLDA\nSEC\nADL\nADH\nMAC\nSTA\n\nLIL 0x6\nLIH 0xE\nMMA\nLDA\nMMA\nLDA\nCLC\nADL\nADH\nLIL 0x7\nLIH 0xE\nMMA\nLDA\nMMA\nMAC\nSTA\n\nLIL 0x6\nLIH 0xE\nMMA\nLDA\nSEC\nADL\nADH\nMAC\nSTA\n\nMMA\nLDA\nCLC\nADL\nADH\n\nLIX loop\nMMA\nJNE\n\nHLT";

    $scope.reset = function () {
        cpu.reset();
        memory.reset();
        $scope.error = '';
        $scope.selectedLine = -1;
    };

    $scope.executeStep = function () {
        if (!$scope.checkPrgrmLoaded()) {
            $scope.assemble();
        }

        try {
            // Execute
            var res = cpu.step();

            // Mark in code
            if (cpu.ip in $scope.mapping) {
                $scope.selectedLine = $scope.mapping[cpu.ip];
            }

            return res;
        } catch (e) {
            $scope.error = e;
            return false;
        }
    };

    var runner;
    $scope.run = function () {
        if (!$scope.checkPrgrmLoaded()) {
            $scope.assemble();
        }

        $scope.isRunning = true;
        runner = $timeout(function () {
            if ($scope.executeStep() === true) {
                $scope.run();
            } else {
                $scope.isRunning = false;
            }
        }, 1000 / $scope.speed);
    };

    $scope.stop = function () {
        $timeout.cancel(runner);
        $scope.isRunning = false;
    };

    $scope.checkPrgrmLoaded = function () {
        for (var i = 0, l = memory.data.length; i < l; i++) {
            if (memory.data[i] !== 0) {
                return true;
            }
        }

        return false;
    };

    $scope.getChar = function (value) {
        var text = String.fromCharCode(value);

        if (text.trim() === '') {
            return '\u00A0\u00A0';
        } else {
            return text;
        }
    };

    $scope.assemble = function () {
        try {
            $scope.reset();

            var assembly = assembler.go($scope.code);
            $scope.mapping = assembly.mapping;
            var binary = assembly.code;
            $scope.labels = assembly.labels;

            if (binary.length > memory.data.length)
                throw "Binary code does not fit into the memory. Max " + memory.data.length + " bytes are allowed";

            for (var i = 0, l = binary.length; i < l; i++) {
                memory.data[i] = binary[i];
            }
        } catch (e) {
            if (e.line !== undefined) {
                $scope.error = e.line + " | " + e.error;
                $scope.selectedLine = e.line;
            } else {
                $scope.error = e.error;
            }
        }
    };

    $scope.jumpToLine = function (index) {
        $document[0].getElementById('sourceCode').scrollIntoView();
        $scope.selectedLine = $scope.mapping[index];
    };


    $scope.isInstruction = function (index) {
        return $scope.mapping !== undefined &&
            $scope.mapping[index] !== undefined &&
            $scope.displayInstr;
    };

    $scope.getMemoryCellCss = function (index) {
        if (index >= $scope.outputStartIndex) {
            return 'output-bg';
        } else if ($scope.isInstruction(index)) {
            return 'instr-bg';
        } else if (index > cpu.sp && index <= cpu.maxSP) {
            return 'stack-bg';
        } else {
            return '';
        }
    };

    $scope.getMemoryInnerCellCss = function (index) {
        if (index === cpu.pc) {
            return 'marker marker-pc';
        } else if (index === cpu.sp) {
            return 'marker marker-sp';
        } else if (index === cpu.gpr[0] && $scope.displayA) {
            return 'marker marker-a';
        } else if (index === cpu.gpr[1] && $scope.displayB) {
            return 'marker marker-b';
        } else if (index === cpu.gpr[2] && $scope.displayC) {
            return 'marker marker-c';
        } else if (index === cpu.gpr[3] && $scope.displayM) {
            return 'marker marker-m';
        } else {
            return '';
        }
    };
}]);
;app.filter('flag', function() {
    return function(input) {
        return input.toString().toUpperCase();
    };
});
;app.filter('number', function() {
    return function(input, isHex) {
        if (isHex) {
            var hex = input.toString(16).toUpperCase();
            return hex.length == 1 ? "0" + hex: hex;
        } else {
            return input.toString(10);
        }
    };
});
;// Source: http://lostsource.com/2012/11/30/selecting-textarea-line.html
app.directive('selectLine', [function () {
    return {
        restrict: 'A',
        link: function (scope, element, attrs, controller) {
            scope.$watch('selectedLine', function () {
                if (scope.selectedLine >= 0) {
                    var lines = element[0].value.split("\n");

                    // Calculate start/end
                    var startPos = 0;
                    for (var x = 0; x < lines.length; x++) {
                        if (x == scope.selectedLine) {
                            break;
                        }
                        startPos += (lines[x].length + 1);
                    }

                    var endPos = lines[scope.selectedLine].length + startPos;

                    // Chrome / Firefox
                    if (typeof(element[0].selectionStart) != "undefined") {
                        element[0].focus();
                        element[0].selectionStart = startPos;
                        element[0].selectionEnd = endPos;
                    }

                    // IE
                    if (document.selection && document.selection.createRange) {
                        element[0].focus();
                        element[0].select();
                        var range = document.selection.createRange();
                        range.collapse(true);
                        range.moveEnd("character", endPos);
                        range.moveStart("character", startPos);
                        range.select();
                    }
                }
            });
        }
    };
}]);
;app.filter('startFrom', function() {
    return function(input, start) {
        start = +start; //parse to int
        return input.slice(start);
    };
});
;app.directive('tabSupport', [function () {
    return {
        restrict: 'A',
        link: function (scope, element, attrs, controller) {
            element.bind("keydown", function (e) {
                if (e.keyCode === 9) {
                    var val = this.value;
                    var start = this.selectionStart;
                    var end = this.selectionEnd;

                    this.value = val.substring(0, start) + '\t' + val.substring(end);
                    this.selectionStart = this.selectionEnd = start + 1;

                    e.preventDefault();
                    return false;
                }
            });
        }
    };
}]);
